#!/usr/bin/python

# auth : dukun@taobao.com
# xssh write by python


import sys
import getopt
import StringIO
import socket
import ConfigParser
import os
import paramiko
import string

# error code exception
class XsshErrorCodeException(Exception):
    message = None
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

# usage for xssh
def usage():
    print """
author : oldmanpushcart@gmail.com
usage  : 
    echo uptime | xssh -i 127.0.0.1 -p 22
    echo uptime | xssh --ip 127.0.0.1 --port 22
    xssh -h
    xssh --help
"""


def parse_from_args():
    ip = None
    port = 22
    timeout = 10
    options,args = getopt.getopt(sys.argv[1:], "hp:i:t:", ["help", "ip=", "port=", "timeout="])
    for key, value in options:  
        if key in ["-h", "--help"]:
            usage()
            sys.exit(0) 
        if key in ["-i", "--ip"]:
            ip = value
        if key in ["-p", "--port"]:
            port = value
        if key in ["-t", "--timeout"]:
            timeout = value
    if ip == None:
        raise XsshErrorCodeException("the --ip/-i is required.")
    return ip, string.atoi(port), string.atof(timeout)
    

def parse_from_xssh_file():
    # read the xssh file from $HOME/.xssh
    cf = ConfigParser.ConfigParser()
    cf.read( os.path.expandvars('$HOME/.xssh'))
    return cf.get("xssh", "username"), cf.get("xssh", "password") 

def read_command_from_stdin():
    cmd_buf = StringIO.StringIO()
    cmd_buf.writelines(sys.stdin.readlines())
    return cmd_buf.getvalue()

def execute_on_ssh(_username, _password, ip, _port, _timeout, cmd):
    
    # connect to ssh server
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(ip, port=_port, username=_username, password=_password, timeout=_timeout)
    chan = ssh.get_transport().open_session()
    
    # execute command
    chan.exec_command(cmd)
    
    # To capture Data. Need to read the entire buffer to caputure output
    contents_buf = StringIO.StringIO()
    error_buf = StringIO.StringIO()
    while not chan.exit_status_ready():
        if chan.recv_ready():
            data = chan.recv(1024)
            while data:
                contents_buf.write(data)
                data = chan.recv(1024)
        if chan.recv_stderr_ready():
            error_buff = chan.recv_stderr(1024)
            while error_buff:
                error_buf.write(error_buff)
                error_buff = chan.recv_stderr(1024)

    return chan.recv_exit_status(), contents_buf.getvalue(), error_buf.getvalue() 
    
    
# the main
if __name__ == "__main__":
    
    status = 0
    try:
        ip, port, timeout = parse_from_args()
        username, password = parse_from_xssh_file()
        command = read_command_from_stdin()
        status, contents, errors = execute_on_ssh(username,password,ip,port,timeout,command)
        sys.stderr.write(errors)
        sys.stdout.write(contents)
    except getopt.GetoptError, ge:
        print >> sys.stderr, "Error! {0}".format(ge)
        sys.exit(1)
    except XsshErrorCodeException, ece:
        print >> sys.stderr, "Error! {0}".format(ece)
        sys.exit(1)
    except paramiko.AuthenticationException:
        print >> sys.stderr, "Error! username/password error, login failed."
        sys.exit(1)
    except socket.error:
        print >> sys.stderr, "Error! can't connect to remote host."
        sys.exit(1)
    except KeyboardInterrupt:
        pass
